## 車作りで学ぶオブジェクト指向

データそのものやそのデータに対する処理を中心に考える時、そのデータの構造の事を **オブジェクト** と呼び、
このオブジェクトを中心にプログラムを設計していく手法を **オブジェクト指向**と呼びます。

## なぜオブジェクト指向？
オブジェクト指向で作る事で、変更に対して柔軟になります。変更されやすい箇所を**オブジェクト**として切り出せるので、実装したい機能を単体で作り、それをパーツを組み合わせるようにアプリケーション開発ができるようになります。

例として、通知機能を考えてみましょう。
通知を行う方法は色々あります。メール、チャット、SMSなどたくさんあります。今後も増えていくかもしれませんので、これはオブジェクトとして切り出しておくべきです。
しかし、通知機能自体を考えた場合はどうでしょう？本質としては、`メッセージを伝えたい。`という所ですよね？
であれば、伝えたいメッセージをオブジェクトに伝え、メッセージを受け取ったオブジェクトは、各々の方法で通知機能を実装して処理することで、
メッセージをメールとか、チャットとかで送る事ができるようになります。

**変更に柔軟になる。これがオブジェクトで作る理由です。**

## オブジェクト指向の考え方
大きく3つ

- カプセル化
- 継承
- 多様性（ポリモーフィズム）

## コード解説
車を作ります。車を構成するパーツは3つ。エンジン、ハンドル、ブレーキです。
それらを組み合わせて車を作ります。

| エンジン | ハンドル | ブレーキ |
| -- | -- | -- |
| 始動する | 右に曲げる | 踏む |
| 停止する | 左に曲げる | 離す |
| 回転数(プロパティ) ||| 

上記がデータ構造です。

### カプセル化
一言にエンジンと言っても世の中には沢山の種類のエンジンがあります。
ガソリンで動くものもあればガスで動くものもあり、エンジンの内部構造も全く異なります。
それらすべてに対して処理を書いていくと大変なことになります。
なので、エンジンの構造がどうなっているのか、どういう原理で動いているのかを隠蔽し、
始動させるか、停止させるかだけを外部に公開し、利用者はそれを呼ぶだけで使えるようにします。
これを**カプセル化**と呼びます。この仕組みにより、エンジンの複雑な仕組みを知らなくてもエンジンを扱うことができます。

### 継承
親クラスの機能を受け継ぐ機能として**継承**があります。
よく親クラスからの機能受け継ぎとして解説される事が多いですが、本質はそこではありません。
親クラスを共通点として引き継ぐ事で、規格に沿ったクラスを作ることができるのが、継承の本質です。
今回の例だと、`Engine.cs`が親クラスとなります。見ての通り抽象クラスであり、親クラス自体に機能は定義していません。
これはあくまで親クラスは共通点を定義しているだけだからです。機能自体はこれを継承する子クラスで定義します。

こういう設計にすることで、
- エンジンを使う側：始動する`（Onメソッド）`、停止する`（Offメソッド）`を呼ぶだけでエンジンを扱える。エンジンの内部構造を知る必要がない。
- エンジンが使われる側：始動する処理が実行されたらエンジンを動かす処理を定義し、停止する処理が実行されたら安全にエンジンを止める処理を定義すれば良い。

と、抽象クラスを定義して処理を子クラスに実装するという設計にすることで実現できるのが、**ポリモーフィズム**です。

### ポリモーフィズム
抽象クラスに対して処理を実装する事で、**抽象クラスを継承した子クラスは、どんなものでも動かす事ができるようになります。**
例えば、エンジンを別のものに載せ替えたいとします。今まで使っていたものとは構造も燃料も違うとします。
抽象クラスを使わなければ、エンジンの構造と動かし方を理解し、定義したメソッドを呼び出すようにエンジンを使う車の方も変更しないといけません。
しかし抽象クラスを継承しておけば、車の方は全く変更することなく、エンジンを載せ替える事ができます。


```csharp
// こうなっていたとして、エンジンを載せ替えたいと思っても？
Engine engine = new JetEngine();
Handle handle = new QuickHandle();
Brake brake = new AntilockBrake();

Car car = new Car(engine, handle, brake);
```

```csharp
// Engineクラスを継承しておけば、インスタンスを差し替えるだけで載せ替え完了。
Engine engine = new ReciproEngine();
Handle handle = new QuickHandle();
Brake brake = new AntilockBrake();

Car car = new Car(engine, handle, brake);
```

もちろん、`ReciproEngine`クラスについては、継承した親クラスの定義の通りに始動と停止の処理を作ってあげればOK。
このように、具体的に処理を実装したクラスに対してではなく、抽象化したクラスに対して処理を実装していく事で**ポリモーフィズム**が実現できます。
